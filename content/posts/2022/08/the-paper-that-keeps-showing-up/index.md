---
title: "The Paper that Keeps Showing Up"
date: 2022-08-14T08:00:01+02:00
draft: true
katex: true
tags:
  - "Cryptography"
  - "ZK Proofs"
---

Let's talk about one of my favorite cryptography papers.
<!--more-->

{{<todo>}}
Introduce the places it's shown up
{{</todo>}}

{{<todo>}}
Generalization of schnorr signatures
{{</todo>}}

# Warmup: Schnorr Proofs

As a bit of a warmup, let's go over how Schnorr proofs work.
This is also a great example to introduce the relevant security notions
we'll be working with, like completeness, soundness, etc.

We'll be working with a cryptographic group $\mathbb{G}$, generated by $G$,
of prime order $q$, and with an associated field of scalars $\mathbb{F}_q$.

In this case of Schnorr proofs, the prover has a secret $x \in \mathbb{F}_q$,
and a public value $X \in \mathbb{G}$.
The prover wants to demonstrate that $X = x \cdot G$, without revealing the value of $x$.

In order for this prover to convince a verifier of this fact, the two of them
run a protocol together:

$$
\boxed{
\begin{aligned}
&\mathcal{P} \text{ knows } x \in \mathbb{F}_q&\quad&\mathcal{V} \text{ knows } X \in \mathbb{G} \cr
\cr
&k \xleftarrow{R} \mathbb{F}_q\cr
&K \gets k \cdot G\cr
&&\xrightarrow{K}\cr
&&&c \xleftarrow{R} \mathbb{F}_q\cr
&&\xleftarrow{c}\cr
&s \gets k + c \cdot x\cr
&&\xrightarrow{s}\cr
&&&s \cdot G \stackrel{?}{=} K + c \cdot X\cr
\end{aligned}
}
$$

The prover generates their random nonce $k$, and then sends $K := k \cdot G$,
which is, in essence, a commitment to this nonce.
The verifier responds in turn with a random challenge $c$,
which the prover then uses to create their response $s$.
Finally, the verifier checks that the response is consistent with the challenge
and the public input $X$.

### Completeness

The first property we'd want a protocol like this to satisfy is *completeness*.
If $x$ is correct, i.e. $X = x \cdot G$, then we'd like the verification
to succeed at the end of the protocol,
assuming that the prover behaves honestly.

To see why this is the case, we need to use the linearity of scalar multiplication:
$$
(a + b) \cdot G = a \cdot G + b \cdot G
$$

If we apply this to the response $s$, we get:

$$
s \cdot G = (k + c \cdot x) \cdot G = k \cdot G+ c \cdot (x \cdot G) = K + c \cdot X
$$

And so, the verification check will pass.

It's crucial here that $s$ is actually equal to $k + c \cdot x$, and that
$X = x \cdot G$, which requires the prover to be honest.
Completeness just says that if the prover is honest, and that the property
they're trying to prove actually holds, then the protocol will succeed.
Completeness doesn't say anything about the case where the prover misbehaves,
or where the property doesn't actually hold.

### Honest Verifier Zero-Knowledge

One way to demonstrate knowledge of a value $x$ such that $x \cdot G = X$
would be to simply reveal the value $x$.
The reason we do this complicated Schnorr protocol instead is because
we want to prove that we know such an $x$ *without* revealing it.
In fact, we don't want to reveal any information about $x$ whatsoever.

This is where the *honest verifier zero-knowledge* property comes in.
In essence, it says that if the verifier behaves honestly, then they don't
learn any information about the secret value $x$ that they couldn't have gotten just by knowing
the public value $X$.

Capturing the notion of "not learning any information" is tricky.
To do this, we use a *simulator* $\mathcal{S}$.
This simulator $\mathcal{S}$ takes as input the public input $X$,
and the challenge $e$, and then creates values $K$ and $s$ which should
have the same distribution of the actual messages sent by the prover in
the real protocol.

The intuition here is that because the verifier can't distinguish between
the messages from a real protocol, and the messages created by the simulator,
then they learn nothing that they didn't know before, since they already
had access to both $X$ and $e$.
It's important that the verifier behave honestly, and choose their challenge
$e$ at random, and not change the way they choose $e$ based on $K$.
Because this challenge $e$ is independent from $K$, you could generate
it before even seeing $K$, which means that the messages that you see
after that, including $K$, could be coming from a simulator instead, without
the verifier realizing it.
On the other hand, if the verifier misbehaves, and chooses $e$ differently
depending on $K$, then our simulation strategy has to work a bit differently.

In this case, the simulator is pretty simple.
We know that the commitment $K$ and response $s$ must satisfy:
$$
s \cdot G = K + e \cdot X
$$

Our simulator $\mathcal{S}$ needs to return $(K, s)$ as a function of $(X, e)$.
One way to do this is to simply choose $s$ at random, and then set:

$$
K \gets s \cdot G - e \cdot X
$$

Because $s$ is random, the value $K$ ends up also being a random group element,
which is that same as for a real execution of the protocol.
Ditto with $s$ itself.

This is enough to show that the Schnorr protocol is honest verifier zero-knowledge.

### 2-Extractability

At this point, we know that if the prover is honest, then they convince
the verifier.
We also know that an honest verifier learns nothing by running the protocol.
But what if the prover is dishonest?

We don't want the prover to be able to convince the verifier unless they
*actually* know an $x$ such that $x \cdot G = X$.

Our strategy to show this will be to use an *extractor*.
The idea is that if we have two transcripts $(K, e, s)$ and $(K, e', s')$,
with $e \neq e'$,
which share the same message, then our extractor $\mathcal{E}$ will be able
to produce a value $\hat{x}$ satisfying $\hat{x} \cdot G = X$.

This means that the prover must have known such a value.
The idea is that you treat the prover as a machine with the value embedded
inside of it, somehow.
Then, you can get these two transcripts by *rewinding* this machine.
After sending the first challenge $e$ and getting the response $s$,
you rewind the machine back to the point where it sent $K$, and now you
send it a new challenge $e'$, and get a new response $s'$.

Intuitively, if the value $x$ is embedded inside of the machine somehow,
then rewinding doesn't change this fact.
If we can successfully extract the value using these two forked transcripts,
that means the value was always present inside of the machine.

Another analogy to explain why this works is that instead of rewinding
the prover, we have access to a time machine.
We can use this time machine to wind back time to when the prover
sent $K$, and use that to get our two transcripts.

Note that this rewinding is really more of a theoretical point, which we use
in proving the soundness of the protocol.
We don't actually need to be able to rewind the protocol.
This rewinding might be problematic for concurrent security, but that's a
can of worms that is best left unopened for now.

With that aside, let's actually create this extractor, shall we?

Given our two transcripts $(K, e, s)$ and $(K, e', s')$ we know that they
must satisfy:

$$
\begin{aligned}
&s \cdot G = K + e \cdot X\cr
&s' \cdot G = K + e' \cdot X\cr
\end{aligned}
$$

If we subtract the two equations, we get:

$$
(s - s') \cdot G = (e - e') \cdot X
$$

Finally, since $e \neq e'$, we can divide by $(e - e')$ to get:

$$
\frac{(s - s')}{(e - e')} \cdot G = X
$$

We now see that if our extractor sets:
$$
\hat{x} \gets (s - s') / (e - e')
$$

then they've managed to find a value $\hat{x}$ such that $\hat{x} \cdot G = X$,
as promised.

## Aside: Sigma Protocols

This Schnorr protocol is a specific example of what we call
a [sigma protocol](https://www.wikiwand.com/en/Proof_of_knowledge#/Sigma_protocols).

This is a three move protocol, wherein the prover sends a commitment,
the verifier samples a random public challenge, the prover sends
a response, and then a verification check based on the transcript
and the public input is run.

The Maurer proofs we'll see in the next section are also sigma protocols.

Because the verifier's challenge is completely public, and the verification
check doesn't depend on any internal state in the verifier, we call
this a *public coin* protocol.

What's nice about public coin protocols is that they can be made *non-interactive*, via the [Fiat-Shamir transform](https://www.wikiwand.com/en/Fiat%E2%80%93Shamir_heuristic).
The idea is that instead of having a verifier choose a challenge,
we instead emulate this choice with a hash function $H$, whose output
should function in the same way as the random challenge.

This allows the prover to create a proof without interacting with anybody else,
and this proof can be independently verified by different people.

[Schnorr signatures](https://www.wikiwand.com/en/Schnorr_signature) are
really just the application of this transform to the protocol we saw earlier,
with the inclusion of the message we want to sign, $m$, inside of the hash
function, so that the proof is "bound" to this specific message.

# Generalization: Maurer Proofs

Maurer proofs {{<ref-link "Mau09">}} can be seen as a *vast* generalization
of Schnorr proofs.

Given a group homomorphism $\varphi : \mathbb{A} \to \mathbb{B}$, they allow
you to prove knowledge of $a \in \mathbb{A}$ such that $\varphi(a) = B$,
without revealing the secret $a$.

{{<note>}}
More specifically, you don't learn anything more about $a$ then you could
have learned from the public value $B$.
{{</note>}}

As a recall, given two groups $\mathbb{A}$ and $\mathbb{B}$, a homomorphism
$\varphi$ is a function from $\mathbb{A}$ to $\mathbb{B}$ such that for
all $a, a' \in \mathbb{A}$, we have:
$$
\varphi(a + a') = \varphi(a) + \varphi(a')
$$

Schnorr proofs are a specific case of these proofs, with the homomorphism:
$$
\begin{aligned}
\varphi &: (\mathbb{F}_q, +) \to \mathbb{G}\cr
\varphi(x) &:= x \cdot G\cr
\end{aligned}
$$

The protocol is very similar to Schnorr proofs as well:

$$
\boxed{
\begin{aligned}
&\mathcal{P} \text{ knows } a \in \mathbb{A}&\quad&\mathcal{V} \text{ knows } B \in \mathbb{B} \cr
\cr
&k \xleftarrow{R} \mathbb{A}\cr
&K \gets \varphi(k)\cr
&&\xrightarrow{K}\cr
&&&c \xleftarrow{R} \mathcal{C}\cr
&&\xleftarrow{c}\cr
&s \gets k + c \cdot a\cr
&&\xrightarrow{s}\cr
&&&\varphi(s) \stackrel{?}{=} K + c \cdot B\cr
\end{aligned}
}
$$

The protocol proceeds in a familar way.
The prover generates a random nonce $k$, sends their commitment $\varphi(k)$,
the verifier responds with a challenge $c$, and the prover
concludes with their response $s$.

The set $\mathcal{C}$ denotes the *challenge space*.
The way we define this set depends on the homomorphism $\varphi$.
We'll see what conditions we need this set to satisfy once we get
to proving extraction for this protocol.

#### Completeness

Completeness holds because $\varphi$ is a homomorphism:

$$
\varphi(s) = \varphi(k + c \cdot a) = \varphi(k) + c \cdot \varphi(a) = K + c \cdot B
$$

#### Honest Verifier Zero-Knowledge

The simulator is also pretty simple to define.

Given a challenge $c$, we know that $K$ and $s$ must satisfy:

$$
\varphi(s) = K + c \cdot B
$$

The idea behind our simulator, like with Schnorr proofs, is
to generate a random $s$, and then define $K$ as a function of $s$, $B$, and $c$:

$$
K \gets \varphi(s) - c \cdot B
$$

Since $s$ is random, this makes $K$ as random as in the real protocol,
and so our simulator works.

## Extraction

Extraction is a bit trickier, because we need to choose our challenge space
$\mathcal{C}$.
This is simple when we know the order of the group $\mathbb{B}$,
but we can also find challenge spaces which work even if the order
of the group is unknown.

Our extract has access to two transcripts $(K, c, s)$ and $(K, c', s')$,
with $c \neq c'$.
These transcripts are valid, and so satisfy:

$$
\begin{aligned}
\varphi(s) &= K + c \cdot B\cr
\varphi(s') &= K + c' \cdot B\cr
\end{aligned}
$$

If we subtract the equations, we get:

$$
\varphi(s) - \varphi(s') = (c - c') \cdot B
$$

Since $\varphi(s)$ is a homomorphism, we can write:

$$
\varphi(s - s') = (c - c') \cdot B
$$

Now, if we knew the order of $\mathbb{B}$, say $q$, then we could
invert $c - c'$ mod $q$, giving us:

$$
\frac{1}{(c - c')} \cdot \varphi(s - s') = B
$$

and then use the fact that $\varphi(s - s')$ is a homomorphism, giving us:

$$
\varphi \left(\frac{s - s'}{c - c'}\right) = B
$$

And we could then use this value as our extractor.

But it turns out that you can make the extraction work even if you don't
know the order.

To get around this, we need to assume the existence of an "anchor value"
$u \in \mathbb{A}$, such that there exists $l$ with:

$$
\varphi(u) = l \cdot B
$$

We also require that $\gcd(l, (c - c')) = 1$ for all $c \neq c' \in \mathcal{C}$.
This entails that there exists coefficients $\alpha, \beta \in \mathbb{Z}$
such that:

$$
\alpha \cdot l + \beta (c - c') = 1
$$

We can then use this to define our extracted value $\hat{x}$:

$$
\hat{x} := \alpha \cdot u + \beta \cdot (s - s')
$$

To see why this works, remember that $\varphi(s - s') = (c - c') \cdot B$,
which means that:

$$
\begin{aligned}
\varphi(\hat{x}) &=\cr
\varphi(\alpha \cdot u + \beta \cdot (s - s')) &=\cr
\alpha \cdot \varphi(u) + \beta \cdot \varphi(s - s') &=\cr
\alpha \cdot l \cdot B + \beta \cdot \varphi(c - c') \cdot B &=\cr
(\alpha \cdot l + \beta \cdot \varphi(c - c')) \cdot B &=\cr 1 \cdot B &= B\cr
\end{aligned}
$$

We also need the set $\mathcal{C}$ to be large enough, i.e. $|\mathcal{C}| \geq 2^\lambda$, with $\lambda$ our security parameter.

## Examples of Extraction

In summary, we need a large set $\mathcal{C}$ such that for any $c \neq c' \in \mathcal{C}$, there exists an anchor value $u$ and exponent $l$ such that:

$$
\varphi(u) = l \cdot B
$$

and $\gcd(l, c - c') = 1$.

Let's see a few examples of how this works.

### Extraction for Groups of Known Prime Order

If you know the order of a group $\mathbb{B}$,
and this group has prime order $q$, then you can easily create this set.

The element $0 \in \mathbb{A}$ can act as our anchor value, since $q \cdot B = 0 = \varphi(0)$, no matter what value $B$ has.

Furthermore, if we take $\mathcal{C} = \mathbb{F}_q$, then the difference
between any two elements in $\mathbb{F}_q$ will be coprime with $q$,
since $q$ is a prime number, and the difference will be $< q$.

In fact, instead of using the order of the group, it suffices to use
the exponent.
This is a value $e$ such that $e \cdot B = 0$ for any value $B \in \mathbb{B}$.
When taking the product of several groups, this will be smaller than
the order, which is nice.

### Extraction for RSA

{{<note>}}
In this section, and when mentioning RSA later, I will switch to the **inferior**
multiplicative notation, because I fear that the world is not yet ready
for additive notation RSA.
{{</note>}}

Let's say that you want to do this for an RSA group $(\mathbb{Z}/(N), \cdot)$.
The issue is that you don't know the order of this group.

The homomorphism in this case is:

$$
\varphi(x) := x^e
$$

(done modulo $N$)

You also know a public value $y$, claimed to equal $x^e$ for some secret $x$.

This homomorphism naturally guides our choice of anchor.
We need to find a $u$ such that $\varphi(u) = y^l$.
Unraveling $\varphi$, we need $u^e = y^l$.

Well, one simple way to satisfy this is to take $l = e$ and $u = y$, giving
us the equation:

$$
y^e = y^e
$$

Now, we need to find a set $\mathcal{C}$ where the difference with any
two elements is coprime with $e$.
This is quite simple if $e$ is a prime number, which is usually the case:
we can simply take $\mathcal{C} = \mathbb{Z}/(e)$.
All (non-negative) numbers $< e$ will have difference which is coprime
with $e$, since $e$ is prime.

Now, if $e$ is a small prime number, then we'll need to repeat our
protocol several times for soundness.
For example, if $e$ is $3$, then we'd need to repeat our protocol
$128 / 3$ times, for $128$ bit security.

## Summary

In summary, given a group homomorphism $\varphi : \mathbb{A} \to \mathbb{B}$,
Maurer proofs are a sigma protocol for proving knowledge of a secret $a \in \mathbb{A}$ such that $\varphi(a) = B$, for a public $B$.

The only assumption we need to make about the groups is that 
we can construct a set $\mathcal{C}$ such that there exists
an exponent $l \in \mathbb{Z}$, with $\gcd(l, (c - c')) = 1$ for all $c \neq c' \in \mathcal{C}$, and an anchor $u \in \mathbb{A}$ satisfying:

$$
\varphi(u) = l \cdot B
$$

# Some Applications

## Schnorr Proofs

## Guillou-Quisquater Proofs

## Parallel Schnorr

## Pedersen Commitment Proofs

## Oblivious PRFs

## Attribute-Based Credentials

## TWW Polynomial Commitment Scheme

# Conclusion

# References

{{<ref
  "Mau09"
  "https://crypto.ethz.ch/publications/files/Maurer09.pdf"
  "[Mau09] Unifying Zero-Knowledge Proofs of Knowledge - Ueli Maurer">}}
