---
title: "The Paper that Keeps Showing Up"
date: 2022-08-14T08:00:01+02:00
draft: true
katex: true
tags:
  - "Cryptography"
  - "ZK Proofs"
---

Let's talk about one of my favorite cryptography papers.
<!--more-->

{{<todo>}}
Introduce the places it's shown up
{{</todo>}}

{{<todo>}}
Generalization of schnorr signatures
{{</todo>}}

# Warmup: Schnorr Proofs

As a bit of a warmup, let's go over how Schnorr proofs work.
This is also a great example to introduce the relevant security notions
we'll be working with, like completeness, soundness, etc.

We'll be working with a cryptographic group $\mathbb{G}$, generated by $G$,
of prime order $q$, and with an associated field of scalars $\mathbb{F}_q$.

In this case of Schnorr proofs, the prover has a secret $x \in \mathbb{F}_q$,
and a public value $X \in \mathbb{G}$.
The prover wants to demonstrate that $X = x \cdot G$, without revealing the value of $x$.

In order for this prover to convince a verifier of this fact, the two of them
run a protocol together:

$$
\boxed{
\begin{aligned}
&\mathcal{P} \text{ knows } x \in \mathbb{F}_q&\quad&\mathcal{V} \text{ knows } X \in \mathbb{G} \cr
\cr
&k \xleftarrow{R} \mathbb{F}_q\cr
&K \gets k \cdot G\cr
&&\xrightarrow{K}\cr
&&&c \xleftarrow{R} \mathbb{F}_q\cr
&&\xleftarrow{c}\cr
&s \gets k + c \cdot x\cr
&&\xrightarrow{s}\cr
&&&s \cdot G \stackrel{?}{=} K + c \cdot X\cr
\end{aligned}
}
$$

The prover generates their random nonce $k$, and then sends $K := k \cdot G$,
which is, in essence, a commitment to this nonce.
The verifier responds in turn with a random challenge $c$,
which the prover then uses to create their response $s$.
Finally, the verifier checks that the response is consistent with the challenge
and the public input $X$.

### Completeness

The first property we'd want a protocol like this to satisfy is *completeness*.
If $x$ is correct, i.e. $X = x \cdot G$, then we'd like the verification
to succeed at the end of the protocol,
assuming that the prover behaves honestly.

To see why this is the case, we need to use the linearity of scalar multiplication:
$$
(a + b) \cdot G = a \cdot G + b \cdot G
$$

If we apply this to the response $s$, we get:

$$
s \cdot G = (k + c \cdot x) \cdot G = k \cdot G+ c \cdot (x \cdot G) = K + c \cdot X
$$

And so, the verification check will pass.

It's crucial here that $s$ is actually equal to $k + c \cdot x$, and that
$X = x \cdot G$, which requires the prover to be honest.
Completeness just says that if the prover is honest, and that the property
they're trying to prove actually holds, then the protocol will succeed.
Completeness doesn't say anything about the case where the prover misbehaves,
or where the property doesn't actually hold.

### Honest Verifier Zero-Knowledge

One way to demonstrate knowledge of a value $x$ such that $x \cdot G = X$
would be to simply reveal the value $x$.
The reason we do this complicated Schnorr protocol instead is because
we want to prove that we know such an $x$ *without* revealing it.
In fact, we don't want to reveal any information about $x$ whatsoever.

This is where the *honest verifier zero-knowledge* property comes in.
In essence, it says that if the verifier behaves honestly, then they don't
learn any information about the secret value $x$ that they couldn't have gotten just by knowing
the public value $X$.

Capturing the notion of "not learning any information" is tricky.
To do this, we use a *simulator* $\mathcal{S}$.
This simulator $\mathcal{S}$ takes as input the public input $X$,
and the challenge $e$, and then creates values $K$ and $s$ which should
have the same distribution of the actual messages sent by the prover in
the real protocol.

The intuition here is that because the verifier can't distinguish between
the messages from a real protocol, and the messages created by the simulator,
then they learn nothing that they didn't know before, since they already
had access to both $X$ and $e$.
It's important that the verifier behave honestly, and choose their challenge
$e$ at random, and not change the way they choose $e$ based on $K$.
Because this challenge $e$ is independent from $K$, you could generate
it before even seeing $K$, which means that the messages that you see
after that, including $K$, could be coming from a simulator instead, without
the verifier realizing it.
On the other hand, if the verifier misbehaves, and chooses $e$ differently
depending on $K$, then our simulation strategy has to work a bit differently.

In this case, the simulator is pretty simple.
We know that the commitment $K$ and response $s$ must satisfy:
$$
s \cdot G = K + e \cdot X
$$

Our simulator $\mathcal{S}$ needs to return $(K, s)$ as a function of $(X, e)$.
One way to do this is to simply choose $s$ at random, and then set:

$$
K \gets s \cdot G - e \cdot X
$$

Because $s$ is random, the value $K$ ends up also being a random group element,
which is that same as for a real execution of the protocol.
Ditto with $s$ itself.

This is enough to show that the Schnorr protocol is honest verifier zero-knowledge.

### 2-Extractability

At this point, we know that if the prover is honest, then they convince
the verifier.
We also know that an honest verifier learns nothing by running the protocol.
But what if the prover is dishonest?

We don't want the prover to be able to convince the verifier unless they
*actually* know an $x$ such that $x \cdot G = X$.

Our strategy to show this will be to use an *extractor*.
The idea is that if we have two transcripts $(K, e, s)$ and $(K, e', s')$,
with $e \neq e'$,
which share the same message, then our extractor $\mathcal{E}$ will be able
to produce a value $\hat{x}$ satisfying $\hat{x} \cdot G = X$.

This means that the prover must have known such a value.
The idea is that you treat the prover as a machine with the value embedded
inside of it, somehow.
Then, you can get these two transcripts by *rewinding* this machine.
After sending the first challenge $e$ and getting the response $s$,
you rewind the machine back to the point where it sent $K$, and now you
send it a new challenge $e'$, and get a new response $s'$.

Intuitively, if the value $x$ is embedded inside of the machine somehow,
then rewinding doesn't change this fact.
If we can successfully extract the value using these two forked transcripts,
that means the value was always present inside of the machine.

Another analogy to explain why this works is that instead of rewinding
the prover, we have access to a time machine.
We can use this time machine to wind back time to when the prover
sent $K$, and use that to get our two transcripts.

Note that this rewinding is really more of a theoretical point, which we use
in proving the soundness of the protocol.
We don't actually need to be able to rewind the protocol.
This rewinding might be problematic for concurrent security, but that's a
can of worms that is best left unopened for now.

With that aside, let's actually create this extractor, shall we?

Given our two transcripts $(K, e, s)$ and $(K, e', s')$ we know that they
must satisfy:

$$
\begin{aligned}
&s \cdot G = K + e \cdot X\cr
&s' \cdot G = K + e' \cdot X\cr
\end{aligned}
$$

If we subtract the two equations, we get:

$$
(s - s') \cdot G = (e - e') \cdot X
$$

Finally, since $e \neq e'$, we can divide by $(e - e')$ to get:

$$
\frac{(s - s')}{(e - e')} \cdot G = X
$$

We now see that if our extractor sets:
$$
\hat{x} \gets (s - s') / (e - e')
$$

then they've managed to find a value $\hat{x}$ such that $\hat{x} \cdot G = X$,
as promised.

## Aside: Sigma Protocols

This Schnorr protocol is a specific example of what we call
a [sigma protocol](https://www.wikiwand.com/en/Proof_of_knowledge#/Sigma_protocols).

This is a three move protocol, wherein the prover sends a commitment,
the verifier samples a random public challenge, the prover sends
a response, and then a verification check based on the transcript
and the public input is run.

The Maurer proofs we'll see in the next section are also sigma protocols.

Because the verifier's challenge is completely public, and the verification
check doesn't depend on any internal state in the verifier, we call
this a *public coin* protocol.

What's nice about public coin protocols is that they can be made *non-interactive*, via the [Fiat-Shamir transform](https://www.wikiwand.com/en/Fiat%E2%80%93Shamir_heuristic).
The idea is that instead of having a verifier choose a challenge,
we instead emulate this choice with a hash function $H$, whose output
should function in the same way as the random challenge.

This allows the prover to create a proof without interacting with anybody else,
and this proof can be independently verified by different people.

[Schnorr signatures](https://www.wikiwand.com/en/Schnorr_signature) are
really just the application of this transform to the protocol we saw earlier,
with the inclusion of the message we want to sign, $m$, inside of the hash
function, so that the proof is "bound" to this specific message.

# Generalization: Maurer Proofs

## Extraction

### Extraction for Groups of Known Order

### Extraction for RSA

# Some Applications

## Schnorr as a Special Case

## Parallel Schnorr

## Pedersen Commitment Proofs

## Oblivious PRFs

## Attribute-Based Credentials

## TWW Polynomial Commitment Scheme

# Conclusion