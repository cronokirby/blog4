---
title: "DKGs in Groups"
date: 2022-10-07
draft: false
katex: true
tags:
  - "Cryptography"
  - "Protocols"
---

This is a short post on *distributed key generation* (DKG)
in the context of cryptographic groups, such as elliptic curves.

<!--more-->

Many cryptographic schemes use a *secret key*, and a *public key*.
As their names suggest, one of them has to be kept private, and the other
can---and should be---shared.
The function these serve depends on the protocol: for signatures,
the public key is used to verify signatures, and the secret key is used
to create them; for encryption, the public key is used to encrypt,
and the secret key is used to decrypt.

Distributed key generation is a way for a group of people to generate
a public key, along with shares of the secret key.
These shares should be such that nobody knows the actual secret,
and yet further protocols can make use of these shares to do useful
operations, such as signing, or decryption.

I've been thinking about DKGs recently, so I wanted to get a few thoughts
out there as a blog post.

# Key Generation

First, let's look at what kind of keys we'll be generating anyhow.

We'll start with a cryptographic group $\mathbb{G}$, generated by $G$,
of order $q$.
This gives us an associated field of scalars, $\mathbb{F}_q$.
We also assume that various problems related to the discrete logarithm
in $\mathbb{G}$ are hard.
In particular, given $A = a \cdot G$, finding $a$ should be intractable.

When working with such a group, the most common setup for keys
is that a scalar $x \in \mathbb{F}_q$ is the secret key,
and the associated point $X := x \cdot G$ is the corresponding public key.

Key generation here is quite simple:

1. Sample $x \xleftarrow{\\$} \mathbb{F}_q$.
2. Return $(x, x \cdot G)$.

Now, just generating a key to use yourself isn't all that interesting.
What *is* more interesting is generating shares of a key for multiple people.
One basic strategy here is *linear* sharing.
We pick shares $x_1, \ldots, x_n$ such that $\sum_i x_i = x$.

If we have a trusted third party, then they can be the "dealer",
and the distribute the shares $x_1, \ldots, x_n$, while informing
the group of the public key $X := x \cdot G$.

What's interesting is how to *remove* this dealer, so that a group
of people can set up a key without needing to trust a third party.

# A Broken Protocol

The way that they'll do this will be with some kind of *protocol*.
This is a program that they'll run together, by doing computation locally,
and exchanging messages.
The goal of the protocol will be for each party $P_i$ to end up with
their share $x_i$, along with the public key $X$, which should
satisfy $\sum_i x_i \cdot G = X$.

This protocol shouldn't let a party learn the other shares either.
Ideally, even if participants deviate from the protocol, they shouldn't
be able to learn private information or bias the result either,
but we'll get to security later.

For now, let's just look at the basic principle behind how you'd
make this work.

One simple idea is that each person can generate their share $x_i$,
which implicitly creates a secret $\sum_i x_i$, shared among the participants.
The "hard" part is then learning $X$ without revealing $x$, or any
of the shares.
This can be done by having each person send $X_i := x_i \cdot G$ to everyone else.
You can then sum up these "shares" of the public key, getting $X := \sum_i X_i$.

More formally, the protocol would be:

1. Each $P_i$ generates $x_i \xleftarrow{\\$} \mathbb{F}_q$.
2. Each $P_i$ sets $X_i \gets x_i \cdot G$.
3. $\star$ Each $P_i$ sends $X_i$ to every other party.
4. $\bullet$ Each $P_i$ waits to receive $X_j$ from every other $P_j$.
5. Each $P_i$ sets $X \gets \sum_i X_i$.
6. $\square$ Each $P_i$ returns $(x_i, X)$.

{{<note>}}
To easily identify different parts of a protocol, I use the following
notation:

- $\star$ The party is sending data.
- $\textcolor{red}{\star}$ The party is sending *private* data.
- $\bullet$ The party is waiting to receive data.
- $\blacktriangle$ The party is making some kind of assertion.
- $\square$ The party is returning a value.

{{</note>}}

Now, because computing $x_i$ from $X_i$ is hard, this protocol is
secure, for *honest* participants.
If the parties don't deviate from the protocol, then they won't reveal
extra information.

### Why this is broken

However, this protocol is broken for *malicious* participants.
The reason why is that a malicious participant gains a tremendous
advantage by going "last".
If they wait to receive the messages from other participants,
then they can actually choose the private key $x$ and the public key $X$.

After seeing $X_2, \ldots, X_n$, the malicious party can send
$X - \sum_{i} X_i$, as their "share" $X_1$.
This results in the final public key being $X$.
If the party happens to know the logarithm of $X$, then they now
control the key for the entire group, defeating the purpose of
the key generation.

# A Fixed Protocol

There are two fundamental issues with the protocol so far, with regards
to malicious security:

1. A malicious party can choose their share $X_i$ after seeing all other $X_j$.
2. A malicious party can choose thier $X_i$ without knowing its discrete logarithm.

We can fix 2. by using a [Maurer proof](/posts/2022/08/the-paper-that-keeps-showing-up/), for the function:
$$
\varphi(x) := x \cdot G
$$
which will force a participant to prove that they know the discrete logarithm.

We also still need to fix 1. even with this proof, although the reason why
is a bit more subtle.

Basically, even if you're forced to know the discrete logarithm of the point
you're submitting, it's still possible to *bias* the resulting public key.
For example, it's possible to try a bunch of values for your share $x_i$
until the point $X$ has a particular starting bit in its binary representation.
Can you get a useful bias in a reasonable amount of time?
Probably not.
That said, the functionality that the protocol is trying to implement
says that $X$ is completely random, so any kind of bias introduced
by a malicious participant counts as a violation of the security
properties of the protocol.

To fix this, we need to have each party set their share *before*
they learn the shares of the other parties.
We can do this using *commitments*.
A commitment hides the value underneath it, but once a commitment
is sent, the value hidden underneath can't be changed.
We can then make each party send a commitment to their share,
and then only after receiving every other commitment will a party reveal
their own share.

Since our public shares have a lot of entropy, we can commit to them
by simply using a hash function.

So, the idea now is that each person will generate $x_i$, set
$X_i \gets x_i \cdot G$, and then send $H(X_i)$ to everyone else.
They then wait to receive these commitments before sending out $X_i$.
They then check that the received shares match the commitments, and then
sum them together.

# Threshold Key Generation

## With a Trusted Dealer

# Without a Dealer

# Second Version

# Conclusion
